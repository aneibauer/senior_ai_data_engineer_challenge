"""
Senior Data Engineering Challenge: Advanced Event Data Generator

SENIOR-LEVEL REQUIREMENTS:
This is not a simple data generation task. You must architect a production-grade,
multi-tenant event generation system that simulates realistic enterprise patterns.

ADVANCED REQUIREMENTS:
- Generate events matching the complex multi-tenant schema in IMPLEMENTATION_GUIDE.md
- Implement realistic user journey simulation with session correlation
- Create sophisticated fraud patterns for advanced anomaly detection testing
- Support schema evolution and backward compatibility
- Generate correlated cross-tenant patterns while maintaining data isolation
- Implement realistic seasonal trends, geographic clustering, and time-zone effects
- Handle high-throughput generation (10K+ events/second capability)
- Include realistic data quality issues for testing validation frameworks

ARCHITECTURE EXPECTATIONS:
- Multi-threaded/async generation for performance
- Configurable tenant isolation and data distribution
- Realistic business logic simulation (inventory, pricing, promotions)
- Advanced fraud scenario generation (coordinated attacks, account takeovers)
- Memory-efficient handling of large-scale data generation
- Pluggable output destinations (Kafka, Pulsar, files, direct API)

SENIOR EVALUATION CRITERIA:
- Can you design realistic multi-tenant data patterns?
- Do you understand e-commerce business logic complexities?
- Can you simulate sophisticated fraud scenarios?
- Do you implement efficient, scalable generation patterns?
- Can you handle schema evolution and data quality concerns?

This requires deep understanding of distributed systems, e-commerce business logic,
and production data engineering challenges. Simple random data generation will not suffice.
"""

# Your senior-level implementation here
from data_generator.models.base import Event
from data_generator.models.event_data import EventData, EventType, EventSubType
from data_generator.models.user import UserContext
from data_generator.models.business import BusinessContext
from data_generator.models.interaction import InteractionContext
from data_generator.models.technical import TechnicalContext
from data_generator.models.ml import MLContext

from data_generator.factories.base_factory import make_event_metadata
from data_generator.factories.user_factory import make_user_context
from data_generator.factories.business_factory import make_business_context
from data_generator.factories.interaction_factory import make_interaction_context
from data_generator.factories.technical_factory import make_technical_context
from data_generator.factories.ml_factory import make_ml_context

import orjson  # faster than json
import random


def assemble_event(n:int=10) -> Event:
    """
    Assembles and returns an Event object populated with default and generated context data.
    Parameters:
        n (int): Number of tenants to choose from for tenant_id. Default is 10.
    Returns:
        Event: An Event instance with the following fields populated:
            - schema_version: The version of the event schema.
            - tenant_id: Identifier for the tenant (e.g., merchant).
            - partition_key: Key used for partitioning events (customizable).
            - event_metadata: Metadata about the event, generated by make_event_metadata().
            - event_data: EventData object containing event type, subtype, and various context objects.
            - technical_context: Technical context information, generated by make_technical_context().
            - ml_context: Machine learning context information, generated by make_ml_context().
    """
    return Event(
        schema_version="2.1", #TODO: update schema version as needed
        tenant_id=f"merchant_{random.randint(1,n)}",
        partition_key="user_region_hash",  # customize as needed
        event_metadata=make_event_metadata(),
        event_data=EventData(
            event_type=random.choice(list(EventType)),
            event_subtype=random.choice(list(EventSubType)),
            user_context=make_user_context(),
            business_context=make_business_context(),
            interaction_context=make_interaction_context()
        ),
        technical_context=make_technical_context(),
        ml_context=make_ml_context()
    )


def serialize_event(event: Event) -> bytes:
    return orjson.dumps(event.model_dump(mode="json"))


if __name__ == "__main__":
    event = assemble_event()
    payload = serialize_event(event)
    print(payload.decode())
    #payload can be send to Pulsar 
